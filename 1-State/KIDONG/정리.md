# 상태 소개

## 일단 상태란 무엇일까?

- 컴포넌트 상태
- 전역 상태
- 서버 상태

## 상태를 위한 행동들

- 상태 변경
- 상태 최적화
- 렌더링 최적화
- 불변성
- 상태 관리자

# 올바른 초기값 설정

> 요약 : 초기 상태를 올바르게 설정하자.

- `useState`의 초기값을 넣지 않으면 해당 값은 `undefined`가 된다. 이로 인해 첫 렌더링 시 null로 인한 오류가 발생할 수 있다. 따라서 올바른 초기값 설정이 중요한 이유이다.

```react
const [count, setCount] = useState(0)
const [list, setList] = useState([])
```

# 업데이트되지 않는 값

> 요약 : 업데이트가 되지 않는 일반적인 객체라면 컴포넌트 외부로 내보내기

```react
const Component = () => {
    // 리액트 상태로 바꾼다던가 혹은 아예 외부로 내보낸다.
    // 컴포넌트가 트리거되고 랜더링되는 시점에서 불필요한 참조를 발생시키기 때문이다.
    const INFO = {
        name: "MY Component"
        value" "Clean Code React"
    }

    return ..
}
```

# 플래그 상태

> 요약 : 불리언의 조건일 경우 useState를 대신 플래그로 상태를 정의할 수 있다.

- 플래그 값 : 프로그래밍에서 주로 특정 조건 혹은 제어를 위한 조건을 불리언으로 나타내는 값

```react
// 수정 전
const Component = () => {
    const [isLogin, setIsLogin] = useState(false)

    useEffect(() => {
        if (
            hasToken &&
            hasCookie &&
            hasValidCookie &&
            !isNewUser &&
            isValidToken
        ) {
            setIsLogin(true)
        }
    }, [hasToken, hasCookie, hasValidCookie, isNewUser, isValidToken])

    return <div>{isLogin && "안녕하세요. 반갑습니다!"}</div>
}

// 수정 후
const Component = () => {
    const isLogin =
        hasToken &&
        hasCookie &&
        hasValidCookie &&
        !isNewUser &&
        isValidToken

    return <div>{isLogin && "안녕하세요. 반갑습니다!"}</div>
}
```

# 불필요한 상태

> 요약 : 컴포넌트 내부 변수는 렌더링마다 고유한 값을 가진다. 따라서 useState가 아닌 const로 상태를 선언하는게 좋은 경우가 있다.

- 컴포넌트 내부에서 변수는 렌더링 마다 고유의 값을 가지는 계산된 값이다.

```react
// 수정 전
const Component = () => {
    const [userList, setUserList] = useState(MOCK_DATA)
    const [completedUserList, setCompletedUserList] = useState([])

    useEffect(() => {
        const newList = userList.filter((user) => user.completed === true)

        setCompletedUserList(newList)
    }, [userList])

    return ...
}

// 수정 후
const Component = () => {
    const [userList, setUserList] = useState(MOCK_DATA)
    const completedUserList = userList.filter((user) => user.completed === true)

    return ...
}
```

# useState 대신 useRef

> 요약 : `useState` 대신 `useRef`를 사용하면 컴포넌트의 생명주기와 동일한 리렌더링되지 않는 상태를 만들 수 있다.

- 컴포넌트의 전체적인 수명과 동일하게 지속된 정보를 일관적으로 제공해야 하는 경우에는 `useState`를 사용할 필요가 없다.
- 이러한 패턴이 많이 사용되는 경우가 isMount이다. 리액트 개발진은 isMount와 같은 값을 만들어서 사용하지 말라고 권고한다.

```react
// 수정 전
const Component = () => {
    const [isMount, setIsMount] = useState(false)

    useEffect(() => {
        if (!isMount) {
            setIsMount(true)
        }
    }, [isMount])

    return <div>{isMount && "컴포넌트 마운트 완료"}</div>
}

// 수정 후
const Component = () => {
    const isMount = useRef(false)

    useEffect(() => {
        isMount.current = true

        return () => (isMount.current = false)
    }, [])

    return <div>{isMount && "컴포넌트 마운트 완료"}</div>
}
```

# 연관된 상태 단순화하기

> 요약 : 리액트 상태를 만들 때 연관된 것들끼리 묶어서 처리하면 에러를 방지하고 코드가 간결해진다.

- Keep it simple stupid(단순한게 복잡한 것 보다 낫다는 의미)
- 특히나 프라미스 로직을 작성할때 하나의 상태가 바뀌면 나머지 상태를 동기화해야하는 상황에 직면한다(ex. A라는 상태가 바뀌면 B ,C를 바꾸고, B라는 상태가 바뀌면 A, C를 바꿔야 할때). 이때 상태를 여러 개 만들고 관리하다보면 side effect가 점점 많아진다. 연관된 상태를 단순화를 통해 상태를 한번에 관리할 수 있다.

```react
// 수정 전
const Component = () => {
    const [isLoading, setIsLoading] = useState(false)
    const [isFinish, setIsFinish] = useState(false)
    const [isError, setIsError] = useState(false)

    const fetchData = () => {
        setIsLoading(true)

        fetch(url).then(() => {
            // fetch Data 성공
            setIsLoading(false)
            setIsFinish(true)
        })
        .catch(() => {
            // fetch Data 실패
            setIsError(true)
        })
    }

    useEffect(() => {
        fetchData()
    }, [])

    if (isLoading) return <LoadingComponent />
    if (isFinish) return <SuccessComponent />
    if (isError) return <ErrorComponent />
}

// 수정 후 - 1
const Component = () => {
    const [promiseState, setPromiseState] = useState("init")

    const fetchData = () => {
        setPromiseState("loading")

        fetch(url).then(() => {
            // fetch Data 성공
            setPromiseState("finish")
        })
        .catch(() => {
            // fetch Data 실패
            setPromiseState("error")
        })
    }

    useEffect(() => {
        fetchData()
    }, [])

    if (promiseState === "loading") return <LoadingComponent />
    if (promiseState === "finish") return <SuccessComponent />
    if (promiseState === "error") return <ErrorComponent />
}

// 수정 후 - 2
const PROMISE_STATE = {
    INIT: "init",
    LOADING: "loading",
    FINISH: "finish",
    ERROR: "error"
}

const Component = () => {
    const [promiseState, setPromiseState] = useState(PROMISE_STATE.INIT)

    const fetchData = () => {
        setPromiseState(PROMISE_STATE.LOADING)

        fetch(url).then(() => {
            // fetch Data 성공
            setPromiseState(PROMISE_STATE.FINISH)
        })
        .catch(() => {
            // fetch Data 실패
            setPromiseState(PROMISE_STATE.ERROR)
        })
    }

    useEffect(() => {
        fetchData()
    }, [])

    if (PROMISE_STATE.LOADING) return <LoadingComponent />
    if (PROMISE_STATE.FINISH) return <SuccessComponent />
    if (PROMISE_STATE.ERROR) return <ErrorComponent />
}
```

# 연관된 상태 객체로 묶어내기

> 요약 : 리액트의 상태를 만들 때 객체로 연관된 것들끼리 묶어서 처리할 수 있다.

- 한 가지 상태를 하나의 `useState`로 만들 필요는 없다.
- 왠만하면 여러 상태를 하나의 상태로 관리하는 것이 좋다.
- 선언형 스타일 : 한 가지 상태 조작을 통해 나머지 연관된 상태를 관리할 수 있음

```react
// 수정 전
const Component = () => {
    const [isLoading, setIsLoading] = useState(false)
    const [isFinish, setIsFinish] = useState(false)
    const [isError, setIsError] = useState(false)

    const fetchData = () => {
        setIsLoading(true)

        fetch(url).then(() => {
            // fetch Data 성공
            setIsLoading(false)
            setIsFinish(true)
        })
        .catch(() => {
            // fetch Data 실패
            setIsError(true)
        })
    }

    useEffect(() => {
        fetchData()
    }, [])

    if (isLoading) return <LoadingComponent />
    if (isFinish) return <SuccessComponent />
    if (isError) return <ErrorComponent />
}

// 수정 후 - 1
const Component = () => {
    const [fetchState, setFetchState] = useState({
        isLoading: false,
        isFinish: false,
        isError: false
    })

    const fetchData = () => {
        setFetchState({
            isLoading: true,
            isFinish: false,
            isError: false
        })

        fetch(url).then(() => {
            // fetch Data 성공
            setFetchState({
                isLoading: false,
                isFinish: true,
                isError: false
            })
        })
        .catch(() => {
            // fetch Data 실패
            setFetchState({
                isLoading: false,
                isFinish: false,
                isError: true
            })
        })
    }

    useEffect(() => {
        fetchData()
    }, [])

    if (fetchState.isLoading) return <LoadingComponent />
    if (fetchState.isFinish) return <SuccessComponent />
    if (fetchState.isError) return <ErrorComponent />
}

// 수정 후 - 2
const Component = () => {
    const [fetchState, setFetchState] = useState({
        isLoading: false,
        isFinish: false,
        isError: false
    })

    const fetchData = () => {
        setFetchState((prevState) => ({
            ...prevState,
            isLoading: true
        }))

        fetch(url).then(() => {
            // fetch Data 성공
            setFetchState((prevState) => ({
                ...prevState,
                isLoading: false
                isFinish: true
            }))
        })
        .catch(() => {
            // fetch Data 실패
            setFetchState((prevState) => ({
                ...prevState,
                isLoading: false
                isError: true
            }))
        })
    }

    useEffect(() => {
        fetchData()
    }, [])

    if (fetchState.isLoading) return <LoadingComponent />
    if (fetchState.isFinish) return <SuccessComponent />
    if (fetchState.isError) return <ErrorComponent />
}
```
