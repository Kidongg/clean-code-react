# Chapter 29 - 컴포넌트 소개

### 과거(Legacy)

**스스로 상태를 관리하는 캡슐화된 컴포넌트**

- 컴포넌트 로직은 템플릿이 아니라 자바스크립트로 작성된다.
- 다양한 형식의 데이터를 쉽게 전달 가능하다.
- DOM과는 별개로 상태를 관리 할 수 있다.

### 현재(New)

현재는 많은 사이트와 많은 앱에서 상호작용을 기대한다.
컴포넌트는 마크업으로 뿌릴 수 있는 JS함수이다.

예전과는 다르게 현재에는 많은 인터렉티브한 상호작용들이 요구된다.

사용자마자 컴포넌트의 기준은 전부 다르다. 누군가는 컴포넌트라고 볼 수도 있는 것을 다른 이는 프레임워크라고 생각 할 수도 있다. 그러기에 컴포넌트는 어떠한 것인가에 대한 개인의 기준점이 있다면 좋을 것 같다.

# Chapter 30 - Self-Closing Tag

셀프클로징 태그는 **명시적으로 닫는 태그가 필요 없는**코드이다.

Veiw 프레임워크를 사용하면 `<header></header>`를 사용할 수 없게 되어있다. 그래서 `<v-header></v-header>`라고 사용한다고 한다.

반면 리액트에서는 그런 구분점이 없다.

만약 LoawerCase를 사용해서 컴포넌트를 만든다고 할 때, 기본 HTML요소인지 아닌지 모를 수 있기에 명확한 차이를 구분지어야 한다.

### 요약

자식 요소를 가질 수 없는 Void Element에 대해 알고, 닫는 태그가 정말 필요한지 파악하자.

<br>

# Chapter 31 - Fragment 지향하기

리액트를 사용하면 항상 지켜야하는 규칙이 있다.
**부모 요소를 꼭 넣어야 한다는 것!**

하지만 부모요소에 `<div></div>` 태그를 사용해서 부모요소를 채우면 불필요한 노드를 추가함으로서 성능적으로도 좋지않고 스타일링에 문제가 생길 가능성또한 있다.

가능하다면 `React.Fragment`를 사용하자!

다만, 리액트 16버전 미만이나 바벨 버전이 7ver 미만에서는 `React.Fragment`기능을 사용 할 수 없다는 부분을 참고하면 좋을 것 같다.

<br>

# Chapter 32 - Fragment 지양하기

```js
const StringRender = () => {
  return <>Only Sting Render!!</>;
};
```

만약 컴포넌트에서 오직 문자열만을 렌더링해야 하는 경우, 컴포넌트에 꼭 Fragment로 감싸 반환할 필요 없다.

```js
const StringRender = () => {
  return "Only Sting Render!!";
};

// 배열로 내보내도 전혀 문제없다.
const StringRender = () => {
  return ["Only", "String", "Render!!"];
};
```

잘못사용한다고 문제가 되는건 아니지만, 좀 더 좋고 올바른 코드가 되기 위해서 Fragment가 불필요하게 사용되는지 아닌지 확인 할 필요가 있다.

<br>

# Chapter 33 - 알아두면 좋은 컴포넌트 네이밍

일반적으로 컴포넌트는 pascal case를 쓴다.

그렇지만 최근 Next.js를 많이 사용하면서 route 베이스 파일명을 kebab case로 사용하는 경우가 있다.

`component-nameing.tsx -> <ComponentNaming/>`

아니면 최근에는 컴포넌트를 만들 때, 컴포넌트의 이름으로 파일을 생성하고 index.tsx파일을 만들기도 한다.
`component-nameing/index.tsx -> <ComponentNaming/>`

결과적으로는 파일명과 별개로 컴포넌트 네이밍 자체는 생태계의 룰을 따르는게 좋다.

<br>

# Chapter 34 - JSX 컴포넌트 함수로 변환

```js
const ReturnJSXFunc = () => {
  const TopRender = () => {
    return (
      <header>
        <h1>Clena Code</h1>
      </header>
    );
  };

  return <div>{TopRender()}</div>;
};
```

이와같이 컴포넌트로 명시하여 내보내는게 아니라 함수로서 실행시키면 작동은 잘 될 수도 있다. 하지만 이러한 방법은 매우 좋지 않은 방법이다.

1. 스코프가 꼬일 수 있다.
2. 컴포넌트인지 무엇인지 코드를 파악하기 매우 어렵다.
3. 반환값을 알기 어렵다.
4. props를 전달하는 방식이 어렵고, 일방적인 패턴이 아니다.

특별한 이유가 없다면 이렇게 하지말자...

<br>

# Chapter 35 - 컴포넌트 내부에 컴포넌트 선언

1. 결합도가 증가한다.
   - 구조적으로 스코프적으로 종속된 개발이 된다.
   - 나중에 확장성이 생겨서 분리할 때 굉장히 힘들다.
2. 성능이 저하된다.
   - 삼위컴포넌트가 리렌더 될 경우, 하위컴포넌트는 재생성되기에 이로 인해서 성능적으로 좋지 않다.

사실 컴포넌트 내부에 컴포넌트를 생성하는게 좋지 않다고 생각은 한다. 그래도 지금 만들고자 하는 컴포넌트안에 사용되는 내부 컴포넌트는 오로지 하나의 컴포넌트에서만 사용할 건데 굳이 또 파일을 새로 만들 필요가 있나?

라는 생각을 때론 하고는 한다.

그렇지만 이러한 생각은 매우 좋지 않은 생각이기에, 파일을 하나 더 만들더라도 확장성이나 성능을 고려하여 컴포넌트를 분리하는게 좋다고 한다.

### 장점

- 성능 최적화: 컴포넌트가 재정의되지 않기 때문에 React의 최적화 기능을 활용할 수 있습니다.
- 가독성: 컴포넌트 구조가 더 명확하고, 코드 가독성이 향상됩니다.
- 유지보수성: 코드가 더 모듈화되고, 유지보수가 용이합니다.
- 재사용성: 컴포넌트를 여러 곳에서 재사용할 수 있습니다.

<br>

# Chapter 36 - displayName

먼저, displayName은 디버깅과 개발 도구에서 컴포넌트를 더욱 쉽게 파악 할 수 있게 이름을 붙여주는 기능이다.

사용방법은

```js
const MyComponent = () => {
  return <div>My Component</div>;
};

MyComponent.displayName = "MyComponent";

export default MyComponent;
```

처럼 `컴포넌트명.displayName` 으로 사용한다. 컴포넌트가 아니라도, 함수명이 될 수도 있다.

이는 익명함수 컴포넌트나 고차 컴포넌트에서 특히나 유용하며, 차후 프로젝트나 코드를 완성 한 후 유지보수나 코드 이해 및 가독성 측면에서 아주 좋은 역할을 하기 때문에 사용에 습관을 들이면 좋다.

<br>

# Chapter 37 - 컴포넌트 구성하기

컴포넌트를 구성할 때,

1. 변하지 않는 값은 함수 밖으로 빼내어 정의하고 사용한다.
2. 타입스크립트를 사용한다면 interface나 type alsas를 사용 할 텐데, 이는 프로젝트의 명세서에 맞게 잘 맞춰 사용하도록 하자. (interface와 type은 난제지만, 가능하다면 interface를 쓰도록 하자.)
3. 가장 처음은 플래그성 상태, 서드파티 라이브러리(React Query), 커스텀 훅, 컴포넌트 내부 상태(useState)의 순서대로 사용한다.

- 이 방법은 강사님이 그렇게 사용한다는 이야기이고, 자기만의 깔끔한 코드구성을 일관적으로 유지하는게 좋다 라고 말하는 것 같다.

<br>
